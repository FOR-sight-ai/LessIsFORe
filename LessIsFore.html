<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Less is FORe.html - Minimalist agentic AI Assistant</title>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        /* --- Styles Originaux Conserv√©s --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 5px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            height: 96vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px;
            text-align: center;
        }

        .config-toggle,
        .open-folder-button,
        .clear-button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 14px;
            transition: background 0.3s;
        }

        .config-panel {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: none;
        }

        .config-panel.active {
            display: block;
        }

        .config-field {
            margin-bottom: 15px;
        }

        .config-field label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 14px;
        }

        .config-field input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafafa;
        }

        .message {
            margin-bottom: 16px;
            display: flex;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            word-wrap: break-word;
            position: relative;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.assistant .message-content {
            background: white;
            color: #333;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding-top: 40px;
        }

        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
            color: #667eea;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
        }

        /* --- Nouveaux Styles pour les Outils --- */
        .message.tool {
            justify-content: center;
            margin-bottom: 8px;
        }

        .tool-content {
            background: #f0f0f0;
            color: #666;
            font-family: monospace;
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 4px;
            border-left: 3px solid #764ba2;
        }

        .pretty-list {
            padding-left: 20px;
            margin: 10px 0;
        }

        .pretty-list li {
            margin: 5px 0;
            list-style-type: disc;
            list-style-position: inside;
        }

        /* Markdown & Inputs */
        .message.assistant .message-content pre {
            background: #282c34;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            color: #abb2bf;
        }

        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }

        .input-container textarea {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 12px;
            resize: none;
            min-height: 50px;
        }

        .input-container button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
        }

        .typing-indicator span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            animation: typing 1.4s infinite;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-10px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div>
                <button class="config-toggle" onclick="toggleConfig()">‚öôÔ∏è Configuration</button>
                <button class="clear-button" onclick="clearConversation()">üóëÔ∏è Clear Chat</button>
                <button class="open-folder-button" onclick="pickDirectory()">üìÅ Open Folder</button>
            </div>
        </div>

        <div class="config-panel" id="configPanel">
            <div class="config-field">
                <label for="apiAddress">API Address:</label>
                <input type="text" id="apiAddress" placeholder="http://localhost:8000" value="http://localhost:8000">
            </div>
            <div class="config-field">
                <label for="apiKey">API Key:</label>
                <input type="password" id="apiKey" placeholder="Enter your API key" value="XXX">
            </div>
            <div class="config-field">
                <label for="modelName">Model Name:</label>
                <input type="text" id="modelName" value="mistral">
            </div>
        </div>

        <div class="chat-container" id="chatContainer"></div>

        <div class="input-container">
            <textarea id="userInput" placeholder="Type your message..." onkeydown="handleKeyPress(event)"></textarea>
            <button onclick="sendMessage()" id="sendBtn">Send</button>
        </div>
    </div>

    <script>
        let isLoading = false;
        let conversationHistory = [];
        let rootHandle = null;

        marked.setOptions({
            highlight: (code, lang) => (lang && hljs.getLanguage(lang)) ? hljs.highlight(code, { language: lang }).value : hljs.highlightAuto(code).value,
            breaks: true, gfm: true
        });

        function toggleConfig() { document.getElementById('configPanel').classList.toggle('active'); }
        function clearConversation() { conversationHistory = []; document.getElementById('chatContainer').innerHTML = ''; }

        async function pickDirectory() {
            try {
                rootHandle = await window.showDirectoryPicker({ mode: "read" });
                addMessage("Folder access granted (read-only): " + rootHandle.name + "\n WARNING : be sure that you use a confidential LLM API", "assistant", "System: Folder ready.");
            } catch (err) { alert("Directory access is required for file tools."); }
        }

        // --- TOOL DEFINITIONS ---
        const FileLib = {
            // Lecture PDF
            async pdfToText(arrayBuffer) {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    text += `[Page ${i}]\n` + content.items.map(s => s.str).join(" ") + "\n";
                }
                return text;
            },

            // Lecture XML pour DOCX/PPTX
            async getOfficeXML(arrayBuffer, type) {
                const zip = await JSZip.loadAsync(arrayBuffer);
                const parser = new DOMParser();

                if (type === 'docx') {
                    const mainFile = "word/document.xml";
                    if (!zip.file(mainFile)) return "XML DOCX not found (word/document.xml).";
                    const xmlString = await zip.file(mainFile).async("string");
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                    // Dans Word, le texte est dans les balises <w:t>
                    const textNodes = xmlDoc.getElementsByTagName("w:t");
                    const fullText = Array.from(textNodes).map(node => node.textContent).join("");

                    return fullText;
                }

                if (type === 'pptx') {
                    // 1. Lister tous les fichiers qui correspondent au pattern des slides
                    const slideFiles = Object.keys(zip.files).filter(name =>
                        name.startsWith("ppt/slides/slide") && name.endsWith(".xml")
                    );

                    if (slideFiles.length === 0) return "No slides found in PPTX.";

                    // 2. Trier les slides par num√©ro (slide1.xml, slide2.xml, etc.) 
                    // sinon JSZip risque de les renvoyer dans le d√©sordre (ex: slide1, slide10, slide2)
                    slideFiles.sort((a, b) => {
                        const numA = parseInt(a.match(/\d+/)[0]);
                        const numB = parseInt(b.match(/\d+/)[0]);
                        return numA - numB;
                    });
                    let extractedText = `[Content of PPTX - ${slideFiles.length} slides]\n`;

                    for (const slidePath of slideFiles) {
                        const xmlString = await zip.file(slidePath).async("string");
                        const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                        // Dans PowerPoint, le texte est dans les balises <a:t>
                        const textNodes = xmlDoc.getElementsByTagName("a:t");

                        // On concat√®ne le texte de la slide en ajoutant un espace entre les blocs
                        const slideText = Array.from(textNodes)
                            .map(node => node.textContent)
                            .join(" ")
                            .replace(/\s+/g, ' ') // Nettoie les espaces multiples
                            .trim();

                        const slideNum = slidePath.match(/\d+/)[0];
                        extractedText += `\n--- SLIDE ${slideNum} ---\n${slideText || "[Slide vide]"}\n`;
                    }
                    return extractedText;
                }

                return "File not supported by XML extraction.";
            }
        };


        const tools = [
            {
                type: "function",
                function: {
                    name: "list_files",
                    description: "LIST FILES & FOLDER STRUCTURE - Essential first step for exploration. Lists all files with metadata (size, last modified date) to understand project layout and identify which files to read. Use BEFORE read_file to: 1) Discover which files exist, 2) Check file sizes to decide if parallel_analyze_content is better than direct reading, 3) Find specific file types (.pdf, .pptx) in subfolders. Supports subfolders at any depth. MOTIVATES use because understanding structure avoids blind reads.",
                    parameters: {
                        type: "object",
                        properties: {
                            max_depth: { type: "integer", default: 2, description: "Maximum directory depth to traverse (1=current only, 2=current+subfolders, 3+=deeper nesting)" },
                            subfolder: { type: "string", description: "Optional: specific subfolder path to list (ex: 'src/components') - useful for focused exploration" }
                        }
                    }
                }
            },
            {
                type: "function",
                function: {
                    name: "read_file",
                    description: "READ FILE CONTENT - Reads text from specific files (supports .txt, .py, .js, .pdf, .docx, .pptx with auto-conversion). WHEN TO USE: Only after list_files shows you the file exists and is reasonably sized. BETTER FOR: Small to medium files (<100KB), when you need specific line ranges, or single critical files. For large files or multiple targets, use parallel_analyze_content instead. SUPPORTS: Line ranges (start_line, end_line) to read portions efficiently.",
                    parameters: {
                        type: "object",
                        properties: {
                            file_name: { type: "string", description: "Path to file (ex: 'src/main.py' or 'docs/report.pdf')" },
                            start_line: { type: "integer", default: 1, description: "Start line for partial reads (useful for large files)" },
                            end_line: { type: "integer", default: -1, description: "End line (-1 means read to end)" }
                        },
                        required: ["file_name"]
                    }
                }
            },
            {
                type: "function",
                function: {
                    name: "parallel_analyze_content",
                    description: "PARALLEL ANALYSIS FOR LARGE DATASETS - Analyzes MULTIPLE large files simultaneously (e.g., all .pptx slides, .pdf documents, code repos). OPTIMAL FOR: 1) Large files (>100KB), 2) Many targets matching glob patterns (*.pptx, src/**/*.py), 3) PPTX/PDF processing where parallel extraction is faster. CHUNKS large files into 10k-word segments with overlap to avoid losing context. MOTIVATES use because: Single read_file on large files is slow; parallel chunks via API enable faster analysis with context preservation. Use search_content first if looking for specific patterns across many files.",
                    parameters: {
                        type: "object",
                        properties: {
                            targets: { type: "array", items: { type: "string" }, description: "Glob patterns of files to analyze in parallel (ex: ['*.pptx', 'data/**/*.pdf', 'src/**/*.py']). Supports ** for recursive, * for wildcards." },
                            prompt: { type: "string", description: "Analysis task/question for each file chunk (ex: 'Extract key insights and action items', 'Summarize technical architecture')" }
                        },
                        required: ["targets", "prompt"]
                    }
                }
            },
            {
                type: "function",
                function: {
                    name: "search_content",
                    description: "GREP-LIKE SEARCH - Searches for text patterns (regex or plain) across multiple files by glob. WHEN TO USE: 1) Need to find specific patterns before analyzing, 2) Locating function definitions, imports, or configuration across codebase, 3) Quick validation across many files. Returns file:line results for targeted reading. BETTER THAN: parallel_analyze_content when you don't need full content, just pattern locations.",
                    parameters: {
                        type: "object",
                        properties: {
                            targets: { type: "array", items: { type: "string" }, description: "List of glob patterns (ex: ['*.txt', 'docs/*.pdf', 'src/**/*.py'])" },
                            query: { type: "string", description: "Text or regex pattern to search (case-insensitive by default)" },
                            case_sensitive: { type: "boolean", default: false, description: "Set true for case-sensitive matching" }
                        },
                        required: ["targets", "query"]
                    }
                }
            }
        ];

        // --- TOOL EXECUTORS ---
        const executors = {
            async list_files({ max_depth = 2, subfolder = "" }) {
                if (!rootHandle) return "Error: No folder opened.";
                const files = [];

                // Navigate to subfolder if specified
                let startHandle = rootHandle;
                if (subfolder) {
                    const parts = subfolder.split('/').filter(p => p && p !== '.');
                    try {
                        for (const part of parts) {
                            startHandle = await startHandle.getDirectoryHandle(part);
                        }
                    } catch (err) {
                        return `Error: Subfolder "${subfolder}" not found: ${err.message}`;
                    }
                }

                // Recursively scan with metadata collection
                async function scan(handle, path = "", depth = 0) {
                    if (depth > max_depth) return;
                    try {
                        for await (const entry of handle.values()) {
                            const rel = path + entry.name;

                            if (entry.kind === 'directory') {
                                files.push({
                                    path: rel + '/',
                                    type: 'directory',
                                    size: '-',
                                    modified: '-'
                                });
                                await scan(entry, rel + "/", depth + 1);
                            } else if (entry.kind === 'file') {
                                try {
                                    const fileHandle = await handle.getFileHandle(entry.name);
                                    const file = await fileHandle.getFile();
                                    const sizeKB = (file.size / 1024).toFixed(2);
                                    const modDate = new Date(file.lastModified).toLocaleString('fr-FR');

                                    files.push({
                                        path: rel,
                                        type: 'file',
                                        size: file.size > 1024 ? `${sizeKB} KB` : `${file.size} B`,
                                        modified: modDate
                                    });
                                } catch (err) {
                                    files.push({
                                        path: rel,
                                        type: 'file',
                                        size: '?',
                                        modified: '?'
                                    });
                                }
                            }
                        }
                    } catch (err) {
                        console.error(`Error scanning directory at ${path}:`, err);
                    }
                }

                await scan(startHandle);

                if (files.length === 0) return "No files found.";

                // Format output with metadata columns
                let output = subfolder ? `üìÇ Contents of "${subfolder}"\n\n` : "üìÇ File Listing:\n\n";
                output += "Path | Size | Last Modified\n";
                output += "---|---|---\n";

                files.forEach(f => {
                    const icon = f.type === 'directory' ? 'üìÅ' : 'üìÑ';
                    output += `${icon} ${f.path} | ${f.size} | ${f.modified}\n`;
                });

                output += `\n‚úì Total: ${files.length} items`;
                return output;
            },
            async read_file({ file_name, start_line = 1, end_line = -1 }) {
                try {
                    if (!rootHandle) throw new Error("No Folder opened.");

                    // Path are written with /
                    const parts = file_name.split('/');
                    let currentHandle = rootHandle;

                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i];
                        if (part === "" || part === ".") continue;
                        currentHandle = await currentHandle.getDirectoryHandle(part);
                    }

                    const fileName = parts[parts.length - 1];
                    const handle = await currentHandle.getFileHandle(fileName);
                    const file = await handle.getFile();

                    // Reading with conversion
                    let text;
                    const ext = fileName.split('.').pop().toLowerCase();

                    if (typeof FileLib !== 'undefined') {
                        if (ext === 'pdf') {
                            text = await FileLib.pdfToText(await file.arrayBuffer());
                        } else if (['docx', 'pptx'].includes(ext)) {
                            text = await FileLib.getOfficeXML(await file.arrayBuffer(), ext);
                        } else {
                            text = await file.text();
                        }
                    } else {
                        text = await file.text();
                    }

                    // Pagination
                    const lines = text.split("\n");
                    const slice = lines.slice(start_line - 1, end_line === -1 ? undefined : end_line);
                    return slice.join("\n");

                } catch (e) {
                    console.error(e);
                    return `Error reading "${file_name}": ${e.message}`;
                }
            },
            async search_content({ targets, query, case_sensitive = false }) {
                if (!rootHandle) return "Error: No folder opened.";

                const results = [];
                const flags = case_sensitive ? "g" : "gi";
                const regex = new RegExp(query, flags);

                // --- √âtape 1 : Trouver tous les fichiers correspondant aux globs ---
                let matchingFiles = [];

                async function findFiles(handle, currentPath = "") {
                    for await (const entry of handle.values()) {
                        const relPath = currentPath + entry.name;
                        if (entry.kind === 'file') {
                            const isMatch = targets.some(target => {
                                const pattern = target
                                    .replace(/\./g, '\\.')
                                    .replace(/\*\*/g, '(.+)')
                                    .replace(/\*/g, '[^/]+');
                                return new RegExp('^' + pattern + '$', 'i').test(relPath);
                            });
                            if (isMatch) matchingFiles.push(relPath);
                        } else if (entry.kind === 'directory') {
                            await findFiles(entry, relPath + "/");
                        }
                    }
                }

                await findFiles(rootHandle);

                if (matchingFiles.length === 0) return "No files matches pattern";

                // --- √âtape 2 : Chercher dans le contenu de chaque fichier ---
                for (const filePath of matchingFiles) {
                    try {
                        // On utilise read_file pour profiter des conversions PDF/Office/XML
                        const content = await this.read_file({ file_name: filePath });
                        const lines = content.split('\n');

                        lines.forEach((lineContent, index) => {
                            if (regex.test(lineContent)) {
                                results.push({
                                    file: filePath,
                                    line: index + 1,
                                    content: lineContent.trim()
                                });
                            }
                            // Reset de l'index regex si global
                            regex.lastIndex = 0;
                        });
                    } catch (err) {
                        console.error(`Error during search in ${filePath}:`, err);
                    }

                    // Limite de s√©curit√© pour ne pas saturer le contexte de l'IA
                    if (results.length > 100) break;
                }

                // --- √âtape 3 : Formater la r√©ponse ---
                if (results.length === 0) return `Aucune occurrence de "${query}" trouv√©e.`;

                let output = `Search result for "${query}" (${results.length} occurrences) :\n\n`;
                results.forEach(res => {
                    output += `üìç ${res.file}:${res.line}\n   > ${res.content}\n\n`;
                });

                if (results.length > 100) output += "... (truncated to 100)";

                return output;
            },
            async parallel_analyze_content({ targets, prompt }) {
                if (!rootHandle) return "Error no Folder opened";

                let allFiles = [];

                // 1. Fonction r√©cursive pour trouver tous les fichiers et leurs chemins relatifs
                async function findFilesRecursively(handle, currentPath = "") {
                    for await (const entry of handle.values()) {
                        const relPath = currentPath + entry.name;
                        if (entry.kind === 'file') {
                            // V√©rification si le fichier correspond √† l'un des patterns glob
                            const isMatch = targets.some(target => {
                                // Conversion simple de glob en Regex (g√®re les sous-dossiers et *)
                                const regexPath = target
                                    .replace(/\./g, '\\.') // √âchappe les points
                                    .replace(/\*\*/g, '(.+)') // ** pour r√©cursivit√© profonde
                                    .replace(/\*/g, '[^/]+'); // * pour un niveau de dossier
                                const regex = new RegExp('^' + regexPath + '$', 'i');
                                return regex.test(relPath);
                            });
                            if (isMatch) allFiles.push(relPath);
                        } else if (entry.kind === 'directory') {
                            await findFilesRecursively(entry, relPath + "/");
                        }
                    }
                }

                await findFilesRecursively(rootHandle);

                if (allFiles.length === 0) {
                    return `Aucun fichier trouv√© pour les cibles : ${targets.join(', ')}. V√©rifiez que vous avez ouvert le bon dossier racine.`;
                }


                const WORD_CHUNK_SIZE = 10000; // 10k mots
                const WORD_OVERLAP = 100;    // 100 mots d'overlap
                let analysisTasks = [];

                // 2. Traitement de chaque fichier trouv√©
                for (const filePath of allFiles) {
                    try {
                        // Lecture du fichier via l'ex√©cuteur existant (g√®re PDF/Office)
                        const content = await this.read_file({ file_name: filePath });

                        // D√©coupage en mots
                        const words = content.split(/\s+/).filter(w => w.length > 0);

                        if (words.length === 0) continue;

                        // Cr√©ation des chunks par mots
                        for (let i = 0; i < words.length; i += (WORD_CHUNK_SIZE - WORD_OVERLAP)) {
                            const chunkText = words.slice(i, i + WORD_CHUNK_SIZE).join(" ");
                            const chunkInfo = `[Fichier: ${filePath} | Mots: ${i} √† ${i + WORD_CHUNK_SIZE}]`;

                            // Cr√©ation de la t√¢che API
                            const task = (async () => {
                                const response = await fetch(document.getElementById('apiAddress').value, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${document.getElementById('apiKey').value}`
                                    },
                                    body: JSON.stringify({
                                        model: document.getElementById('apiModel')?.value || 'mistral',
                                        messages: [
                                            { role: "system", content: "Vous √™tes un analyseur de code expert. R√©pondez de mani√®re concise." },
                                            { role: "user", content: `Analyse ce segment de code/document.\nObjectif : ${prompt}\n\n${chunkInfo}\n\nCONTENU :\n${chunkText}` }
                                        ]
                                    })
                                });

                                if (!response.ok) return `Erreur sur ${chunkInfo}: ${response.statusText}`;
                                const data = await response.json();
                                return `### Analyse de ${filePath} (Segment ${i})\n${data.choices[0].message.content}`;
                            })();

                            analysisTasks.push(task);

                            // Limite de s√©curit√© pour √©viter d'exploser le quota API ou la m√©moire
                            if (analysisTasks.length >= 30) {
                                console.log("30 chunks limit reached");
                                break;
                            }
                        }
                    } catch (err) {
                        console.error(err.message);
                        analysisTasks.push(Promise.resolve(`Error reading ${filePath}: ${err.message}`));
                    }
                }


                // 3. Ex√©cution parall√®le et concat√©nation
                const results = await Promise.all(analysisTasks);
                return results.join("\n\n---\n\n");
            }
        };

        // --- AGENT LOOP ---
        async function sendMessage() {
            if (isLoading) return;
            const input = document.getElementById('userInput');
            const message = input.value.trim();
            if (!message) return;

            const apiAddress = document.getElementById('apiAddress').value + "/chat/completions";
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelName').value;

            if (!apiKey) { addMessage('API Key required!', 'error'); return; }

            addMessage(message, 'user');
            console.log(message)
            conversationHistory.push({ role: 'user', content: message });
            input.value = '';
            isLoading = true;
            document.getElementById('sendBtn').disabled = true;

            try {
                let loop = true;
                while (loop) {
                    showTypingIndicator();
                    const response = await fetch(apiAddress, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({ model: model, messages: conversationHistory, tools: tools })
                    });

                    removeTypingIndicator();
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);

                    const data = await response.json();
                    const assistantMsg = data.choices[0].message;

                    if (assistantMsg.tool_calls) {
                        console.log(assistantMsg);
                        conversationHistory.push(assistantMsg);
                        for (const call of assistantMsg.tool_calls) {
                            const name = call.function.name;
                            const args = JSON.parse(call.function.arguments);

                            addToolCall(`Calling: ${name}(${Object.values(args).join(', ')})`);
                            const result = await executors[name](args);
                            console.log(result);
                            conversationHistory.push({
                                role: "tool",
                                tool_call_id: call.id,
                                name: name,
                                content: String(result)
                            });
                        }
                        // Continuer la boucle pour que l'IA traite les r√©sultats des outils
                    } else {
                        console.log(assistantMsg);
                        conversationHistory.push(assistantMsg);
                        addMessage(assistantMsg.content, 'assistant', assistantMsg.content);
                        loop = false;
                    }
                }
            } catch (error) {
                removeTypingIndicator();
                console.error(error.message);
                addMessage(`Error: ${error.message}`, 'error');
            } finally {
                isLoading = false;
                document.getElementById('sendBtn').disabled = false;
                input.focus();
            }
        }

        // --- UI HELPERS ---
        function addMessage(content, role, rawContent = null) {
            const container = document.getElementById('chatContainer');
            const div = document.createElement('div');
            div.className = `message ${role}`;
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            if (role === 'assistant') {
                const wrapper = document.createElement('div');
                const cleanHTML = DOMPurify.sanitize(marked.parse(content || ""));
                wrapper.innerHTML = cleanHTML;
                wrapper.querySelectorAll('pre code').forEach(el => hljs.highlightElement(el));

                // Add more styling to lists
                wrapper.querySelectorAll('ul, ol').forEach(list => {
                    list.classList.add('pretty-list');
                });

                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-button';
                copyBtn.innerHTML = 'üìã Copy';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(rawContent || content);
                    copyBtn.innerHTML = '‚úì Copied!';
                    setTimeout(() => copyBtn.innerHTML = 'üìã Copy', 2000);
                };
                contentDiv.appendChild(wrapper);
                contentDiv.appendChild(copyBtn);
            } else {
                contentDiv.textContent = content;
            }

            div.appendChild(contentDiv);
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function addToolCall(text) {
            const container = document.getElementById('chatContainer');
            const div = document.createElement('div');
            div.className = 'message tool';
            div.innerHTML = `<div class="tool-content">‚öôÔ∏è ${text}</div>`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function showTypingIndicator() {
            const div = document.createElement('div');
            div.className = 'message assistant';
            div.id = 'typingIndicator';
            div.innerHTML = '<div class="typing-indicator message-content"><span></span><span></span><span></span></div>';
            document.getElementById('chatContainer').appendChild(div);
        }

        function removeTypingIndicator() {
            const el = document.getElementById('typingIndicator');
            if (el) el.remove();
        }

        function handleKeyPress(e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } }
        document.getElementById('userInput').focus();
    </script>
</body>

</html>
